---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)

suppressPackageStartupMessages(library(ribd)) # kappa masks base::kappa
```

# ribd <img src="man/figures/logo.png" align="right" height=140/>


## Overview

The goal of `ribd` is to compute various coefficients of relatedness between pedigree members. It extends the `pedtools` package which provides many useful utilities for pedigree construction and manipulation.

The main functions in ribd are:

* `kinship()` : Computes the autosomal kinship matrix
* `kinshipX()` : Computes the X chromosomal kinship matrix
   
* `kappa()` : Computes the IBD (kappa) coefficients of two non-inbred pedigree members
* `kappaX()` : Computes the X chromosomal IBD coefficients of two non-inbred pedigree members
   
* `condensedIdentity()` : Computes the autosomal condensed identity coefficients of two pedigree members
* `condensedIdentityX()` : Computes the X chromosomal condensed identity coefficients of two pedigree members

A novel feature of `ribd` is the ability to handle pedigrees with inbred founders. More about this below!

## Installation
`ribd` is available for download from GitHub as follows: 
```{r, eval = FALSE}
 # First install devtools if needed
if(!require(devtools)) install.packages("devtools")

# Install ribd from github
devtools::install_github("magnusdv/ribd")
```

## Getting started
```{r example, eval = FALSE}
library(ribd)
```

To illustrate the use of `ribd` we compute the condensed identity coefficients after one generation of full sib mating. This is a suitable example because the answer is well known, and it is one of the simplest in which all 9 coefficients are non-zero. 

We create the pedigree with `pedtools` as follows:
```{r eval = FALSE}
x = fullSibMating(1)
plot(x)
```

```{r sibs, fig.height=3, fig.width=2.5, fig.align="center", echo = FALSE}
x = fullSibMating(1)
plot(x, margin = c(1,1,1,1))
```

The identity coefficients of the children are computed with `condensedIdentity()`
```{r}
condensedIdentity(x, ids = 5:6)
```

## Inbred founders
How would the above result would change if individual 1 was himself inbred? The "normal" approach to answer this question would be to *expand* the pedigree to include the complete family history. For example, if he was the child of half siblings, we could perform this expansion by merging `x` with a suitably labeled half-sib pedigree: 
```{r}
y = halfSibPed(sex1 = 1, sex2 = 2)
y = addChildren(y, father = 4, mother = 5, nch = 1)
y = relabel(y, c(101:105, 1)) # prepare merge by relabeling
z = mergePed(y, x)
```
```{r, eval = FALSE}
plot(z)
```
```{r sibs-extended, fig.height=4, fig.width=3, fig.align="center", echo = FALSE}
plot(z, margin = c(1,1,1,1))
```

Now that we have the complete pedigree we could answer the original question by running `condensedIdentity()` on `z`.
```{r}
condensedIdentity(z, ids = 5:6)
```

Although the above strategy worked nicely in this case, it quickly gets awkward or impossible to model founder inbreeding by creating the complete pedigree. For example, inbreeding coefficients close to zero require enormous pedigrees! And even worse: What if  individual 1 was 100% inbred? This cannot be modelled in this way, as it calls for an infinite pedigree.

A much easier approach is to use the `founderInbreeding()` feature offered by `pedtools`: We simply specify the inbreeding level of individual 1 (in the original `x`) to be that of a child of half siblings, i.e. $1/8$.
```{r}
founderInbreeding(x, ids = 1) = 1/8
```
When we now run `condensedIdentity()` on `x`, this inbreeding is taken into account, giving the same answer as above.
```{r}
condensedIdentity(x, ids = 5:6)
```

NB: For now, only *autosomal* founder inbreeding coefficients are implemented.
